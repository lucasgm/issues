# roles/deploy_service/tasks/host_install_batch.yml

# 1) Collect RPMs + hooks
- name: Collect RPM paths and INSTALL hooks (Linux)
  ansible.builtin.set_fact:
    _rpm_paths_from_plan: >-
      {{
        phase_services | map(attribute='containers') | sum(start=[])
        | selectattr('type','defined') | selectattr('type','equalto','RPM')
        | selectattr('__dest','defined')
        | map(attribute='__dest') | list
      }}
    _install_before: >-
      {{
        phase_services | map(attribute='actionCommands') | sum(start=[])
        | selectattr('action','equalto','INSTALL')
        | selectattr('runStage','equalto','BEFORE')
        | map(attribute='command') | map('trim') | reject('equalto','') | list
      }}
    _install_after: >-
      {{
        phase_services | map(attribute='actionCommands') | sum(start=[])
        | selectattr('action','equalto','INSTALL')
        | selectattr('runStage','equalto','AFTER')
        | map(attribute='command') | map('trim') | reject('equalto','') | list
      }}

- name: Prefer RPM paths captured during DOWNLOAD (if any)
  ansible.builtin.set_fact:
    _rpm_paths: "{{ (downloaded_rpms | default([]) + _rpm_paths_from_plan) | unique }}"
  when: _rpm_paths is not defined

# 2) Choose package manager once (dnf on EL8+/yum on EL7)
- name: Choose package manager
  ansible.builtin.set_fact:
    _pm: >-
      {{
        (ansible_facts.pkg_mgr | default('yum')) in ['dnf','yum4']
        | ternary('dnf','yum')
      }}

# 3) Build proxy + repo flags (include --setopt=proxy= when provided)
- name: Normalize proxy value
  ansible.builtin.set_fact:
    _proxy_val: "{{ (options.PROXY | default('') | string) | trim }}"

- name: Build proxy flag and repo flags
  ansible.builtin.set_fact:
    _proxy_flag: "{{ (((_proxy_val | default('') | string) | trim | length) > 0) | ternary('--setopt=proxy=' ~ _proxy_val, '') }}"
    _repo_flags: "{{ (yum_repo_flags | default('') | string) | trim }}"

# 4) Derive RPM package names from the files (used for safe removal)
- name: Derive package names from RPMs
  ansible.builtin.shell: 'rpm -qp --qf "%{NAME}\n" "{{ item }}"'
  args:
    executable: /bin/bash
  loop: "{{ _rpm_paths }}"
  register: _rpm_qp
  failed_when: false
  changed_when: false
  when: (_rpm_paths | length) > 0

- name: Collect unique package names
  ansible.builtin.set_fact:
    _rpm_pkg_names: >-
      {{
        (_rpm_qp.results | default([]))
        | map(attribute='stdout') | map('trim') | reject('equalto','')
        | list | unique
      }}
  when: (_rpm_paths | length) > 0

# 5) Gate on installed package names, then collect installed NEVRs
- name: Check which package names are already installed
  ansible.builtin.shell: "rpm -q --quiet {{ item }}"
  args: { executable: /bin/bash }
  loop: "{{ _rpm_pkg_names | default([]) }}"
  register: _rpm_q
  failed_when: false
  changed_when: false
  when: (_rpm_pkg_names | default([]) | length) > 0

- name: Build list of installed package names
  ansible.builtin.set_fact:
    _rpm_installed_names: "{{ _rpm_q.results | selectattr('rc','equalto',0) | map(attribute='item') | list }}"
  when: (_rpm_pkg_names | default([]) | length) > 0

- name: Get installed NEVRs for those names
  ansible.builtin.shell: "rpm -q {{ item }}"
  args: { executable: /bin/bash }
  loop: "{{ _rpm_installed_names | default([]) }}"
  register: _rpm_q_nevr
  failed_when: false
  changed_when: false
  when: (_rpm_installed_names | default([]) | length) > 0

- name: Collect installed NEVRs (unique)
  ansible.builtin.set_fact:
    _rpm_installed_nevrs: >-
      {{
        (_rpm_q_nevr.results | default([]))
        | map(attribute='stdout_lines') | list | sum(start=[])
        | map('trim') | reject('equalto','') | list | unique
      }}
  when: (_rpm_installed_names | default([]) | length) > 0

# 6) Build command strings
- name: Build rpm join lists
  ansible.builtin.set_fact:
    _rpm_joined: >-
      {{ (_rpm_paths | default([])) | map('regex_replace','^','"') | map('regex_replace','$','"') | join(' ') }}
    _rpm_joined_nevrs: "{{ (_rpm_installed_nevrs | default([])) | join(' ') }}"

- name: Build install/remove commands (strings)
  ansible.builtin.set_fact:
    _remove_cmd: >-
      {% if ((_rpm_installed_nevrs | default([])) | length) == 0 %}
      echo "No packages to remove on {{ inventory_hostname }}.";
      {% else %}
      /usr/bin/sudo rpm -e --nodeps {{ _rpm_joined_nevrs | default('') }} \
      || /usr/bin/sudo rpm -e --nodeps --noscripts {{ _rpm_joined_nevrs | default('') }} \
      || true
      {% endif %}
    _dnf_install_cmd: >-
      /usr/bin/sudo dnf -y {{ _proxy_flag | default('') }} {{ _repo_flags | default('') }} install --allowerasing --best=0 {{ _rpm_joined | default('') }}
    _dnf_downgrade_cmd: >-
      /usr/bin/sudo dnf -y {{ _proxy_flag | default('') }} {{ _repo_flags | default('') }} downgrade {{ _rpm_joined | default('') }}
    _yum_install_cmd: >-
      /usr/bin/sudo yum -y {{ _proxy_flag | default('') }} {{ _repo_flags | default('') }} install {{ _rpm_joined | default('') }}
    _yum_downgrade_cmd: >-
      /usr/bin/sudo yum -y {{ _proxy_flag | default('') }} {{ _repo_flags | default('') }} downgrade {{ _rpm_joined | default('') }}

# --- TEMP DEBUG: show exactly what we'll run (including proxy propagation) ----
- name: "DEBUG (temp): built remove/install commands with proxy/repo flags"
  ansible.builtin.debug:
    msg: |
      pm: {{ _pm }}
      proxy_flag: {{ _proxy_flag }}
      repo_flags: {{ _repo_flags }}
      rpm_paths: {{ _rpm_paths | to_nice_json }}
      rpm_pkg_names: {{ _rpm_pkg_names | default([]) | to_nice_json }}
      rpm_installed_names: {{ _rpm_installed_names | default([]) | to_nice_json }}
      rpm_installed_nevrs: {{ _rpm_installed_nevrs | default([]) | to_nice_json }}
      remove_cmd: {{ _remove_cmd }}
      install_cmd: {{
        (_pm == 'dnf')
        | ternary(
            _dnf_install_cmd ~ ' || ' ~ _dnf_downgrade_cmd,
            _yum_install_cmd ~ ' || ' ~ _yum_downgrade_cmd
          )
      }}

# ── CHECK MODE: only show what we would do ───────────────────────────────────
- block:
    - name: (check) Which package names are already installed
      ansible.builtin.debug:
        var: _rpm_q
      when: _rpm_q is defined

    - name: (check) BEFORE INSTALL hooks to run
      ansible.builtin.debug:
        var: _install_before
      when: _install_before | length > 0

    - name: (check) Would run remove + single package-manager line
      ansible.builtin.debug:
        msg: >-
          {{ _remove_cmd }}
          &&
          {%- if _pm == 'dnf' -%}
          {{ _dnf_install_cmd }}  ||  {{ _dnf_downgrade_cmd }}
          {%- else -%}
          {{ _yum_install_cmd }}  ||  {{ _yum_downgrade_cmd }}
          {%- endif %}

    - name: (check) AFTER INSTALL hooks to run
      ansible.builtin.debug:
        var: _install_after
      when: _install_after | length > 0

    - name: Record simulated install summary (Linux, check mode)
      ansible.builtin.set_stats:
        aggregate: true
        data:
          install_summary:
            host: "{{ inventory_hostname }}"
            success_artifacts: []
            failed_artifacts: []
  when: ansible_check_mode | default(false)

# ── REAL RUN ─────────────────────────────────────────────────────────────────
- block:
    - name: BEFORE INSTALL hooks
      ansible.builtin.shell: "{{ item }}"
      args:
        executable: /bin/bash
      loop: "{{ _install_before }}"
      register: _before_out
      failed_when: false
      changed_when: true
      when: _install_before | length > 0

    - name: Skip if no RPMs to install on this host
      ansible.builtin.debug:
        msg: "No RPMs to install on {{ inventory_hostname }}."
      when: _rpm_paths | length == 0

    - name: Remove currently-installed packages for these artifacts (by NEVR)
      ansible.builtin.shell: "{{ _remove_cmd }}"
      args:
        executable: /bin/bash
      register: _remove_run
      when: (_rpm_installed_nevrs | default([]) | length) > 0
      changed_when: true
      failed_when: false

    - name: Verify removals (non-fatal check)
      ansible.builtin.shell: |
        set -e
        rc=0
        for n in {{ (_rpm_installed_names | default([])) | join(' ') }}; do
          if rpm -q --quiet "$n"; then
            echo "$n still installed"
            rc=1
          fi
        done
        exit $rc
      args: { executable: /bin/bash }
      register: _remove_verify
      when: (_rpm_installed_names | default([]) | length) > 0
      changed_when: false
      failed_when: false

    - name: Run package install/downgrade (single line)
      ansible.builtin.shell: |
        set -o pipefail
        {% if _pm == 'dnf' %}
        {{ _dnf_install_cmd }} || {{ _dnf_downgrade_cmd }}
        {% else %}
        {{ _yum_install_cmd }} || {{ _yum_downgrade_cmd }}
        {% endif %}
      args:
        executable: /bin/bash
      register: _pm_run
      when: _rpm_paths | length > 0
      changed_when: >
        (_rpm_paths | length > 0) and
        ('Nothing to do' not in ((_pm_run.stdout | default('')) + (_pm_run.stderr | default(''))))

    - name: AFTER INSTALL hooks
      ansible.builtin.shell: "{{ item }}"
      args:
        executable: /bin/bash
      loop: "{{ _install_after }}"
      register: _after_out
      failed_when: false
      changed_when: true
      when: _install_after | length > 0

    - name: Record install summary (Linux)
      ansible.builtin.set_stats:
        aggregate: true
        data:
          install_summary:
            host: "{{ inventory_hostname }}"
            success_artifacts: "{{ (_rpm_paths | length > 0 and (_pm_run.rc | default(0)) == 0) | ternary(_rpm_paths, []) }}"
            failed_artifacts:  "{{ (_rpm_paths | length > 0 and (_pm_run.rc | default(1)) != 0) | ternary(_rpm_paths, []) }}"
  when: not (ansible_check_mode | default(false))

