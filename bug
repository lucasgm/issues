# playbook.yml — ExecPlan-driven deployment

# ───────────────────────────────────────────────────────────────
# Play 1 — Ingest execplan.yml and prepare host phase maps
# ───────────────────────────────────────────────────────────────
- name: Ingest exec plan and build host phase maps
  hosts: localhost
  gather_facts: false

  pre_tasks:
    - name: Load options (for PROXY/ENABLEREPO/DISABLEREPO)
      ansible.builtin.include_vars: vars/vars.yml

  tasks:
    - name: Read EXECPLAN from extra var
      ansible.builtin.set_fact:
        components_raw: >-
          {{ EXECPLAN if (EXECPLAN is not string) else (EXECPLAN | from_yaml) }}

    - name: Sanitize execplan data via JSON serialization (prevent corruption)
      ansible.builtin.set_fact:
        components: "{{ components_raw | to_json | from_json }}"

    - name: Derive component name lists and dependency groups
      ansible.builtin.set_fact:
        components_names: "{{ components | map(attribute='name') | list }}"
        no_dep_components: "{{ components | selectattr('dependsOn','equalto',[]) | map(attribute='name') | list }}"
        dep_components_in_order: "{{ (components | rejectattr('name','in', (components | selectattr('dependsOn','equalto',[]) | map(attribute='name') | list)) | map(attribute='name') | list) }}"

    # Compute dependency levels for INSTALL and for START/HEALTH gating
    - name: Detect presence of action-specific dependency fields
      ansible.builtin.set_fact:
        has_dep_actions: >-
          {{
            (
              components | map(attribute='dependsOn') | sum(start=[])
              | selectattr('currentAction','defined') | list | length
            ) > 0 or (
              components | map(attribute='dependsOn') | sum(start=[])
              | selectattr('dependsOnAction','defined') | list | length
            ) > 0
          }}

    - name: Detect presence of INSTALL-specific dependency fields
      ansible.builtin.set_fact:
        has_install_actions: >-
          {{
            (
              components | map(attribute='dependsOn') | sum(start=[])
              | selectattr('currentAction','defined') | selectattr('currentAction','equalto','INSTALL') | list | length
            ) > 0 or (
              components | map(attribute='dependsOn') | sum(start=[])
              | selectattr('dependsOnAction','defined') | selectattr('dependsOnAction','equalto','INSTALL') | list | length
            ) > 0
          }}

    # Build INSTALL dependency map and compute levels (roots first)
    - name: Build INSTALL gating dependency map (action-aware)
      ansible.builtin.set_fact:
        comp_deps_map_install: >-
          {%- set m = {} -%}
          {%- for c in components -%}
            {%- set deps = [] -%}
            {%- for d in (c.dependsOn | default([])) -%}
              {%- set ca = d.currentAction | default('') -%}
              {%- set doa = d.dependsOnAction | default('') -%}
              {%- set is_orchestration_only = d.orchestrationOnly | default(false) -%}
              {%- if ca == 'INSTALL' and doa == 'INSTALL' and not is_orchestration_only -%}
                {%- if d.componentName is defined and d.componentName -%}
                  {%- set _ = deps.append(d.componentName) -%}
                {%- endif -%}
              {%- endif -%}
            {%- endfor -%}
            {%- set _ = m.update({ (c.name): (deps | unique) }) -%}
          {%- endfor -%}
          {{ m }}
      when: has_install_actions | bool

    - name: Debug orchestrationOnly filtering for INSTALL dependencies
      ansible.builtin.debug:
        msg: |
          🔍 INSTALL DEPENDENCY FILTERING RESULTS:
          
          {% for comp_name in (components_names[:10]) %}
          {% set comp = components | selectattr('name', 'equalto', comp_name) | first %}
          {% if comp.dependsOn is defined %}
          
          {{ comp.name }}:
            Total raw dependencies: {{ comp.dependsOn | length }}
            {% for dep in comp.dependsOn %}
            {% if dep.currentAction | default('') == 'INSTALL' and dep.dependsOnAction | default('') == 'INSTALL' %}
            - {{ dep.componentName }}: orchestrationOnly={{ dep.orchestrationOnly | default('false') }} 
              → {% if dep.orchestrationOnly | default(false) %}❌ EXCLUDED from INSTALL{% else %}✅ INCLUDED in INSTALL{% endif %}
            {% endif %}
            {% endfor %}
            Final INSTALL dependencies: {{ comp_deps_map_install[comp.name] | default([]) | length }} deps
          {% endif %}
          {% endfor %}
      when: has_install_actions | bool and (options.DEBUG | default(false))

    - name: Initialize INSTALL level computation state
      ansible.builtin.set_fact:
        comp_deps_map: "{{ comp_deps_map_install }}"
        _levels: []
        _done: []
        _remaining: "{{ components_names | list }}"
      when: has_install_actions | bool

    - name: Iteratively compute INSTALL dependency levels
      ansible.builtin.include_tasks: roles/deploy_service/tasks/compute_levels_step.yml
      loop: "{{ range(0, (components_names | length) + 1) | list }}"
      loop_control:
        label: "install-levels iteration {{ item }}"
      when: has_install_actions | bool

    - name: Assert INSTALL dependency graph is acyclic
      ansible.builtin.assert:
        that: (_remaining | length) == 0
        fail_msg: >-
          Unresolvable INSTALL deps detected. Remaining components: {{ _remaining }}. Check execplan for cycles or missing names.
      when: has_install_actions | bool

    - name: Persist INSTALL levels and restore comp_deps_map for START/HEALTH computation
      ansible.builtin.set_fact:
        component_levels_install: "{{ _levels }}"
      when: has_install_actions | bool

    - name: Build START gating dependency map (action-aware)
      ansible.builtin.set_fact:
        comp_deps_map: >-
          {%- set m = {} -%}
          {%- for c in components -%}
            {%- set deps = [] -%}
            {%- for d in (c.dependsOn | default([])) -%}
              {%- set ca = d.currentAction | default('') -%}
              {%- set doa = d.dependsOnAction | default('') -%}
              {%- if ca == 'START' and doa in ['HEALTH_CHECK','START'] -%}
                {%- if d.componentName is defined and d.componentName -%}
                  {%- set _ = deps.append(d.componentName) -%}
                {%- endif -%}
              {%- endif -%}
            {%- endfor -%}
            {%- set _ = m.update({ (c.name): (deps | unique) }) -%}
          {%- endfor -%}
          {{ m }}
      when: has_dep_actions | bool

    - name: "Build START gating dependency map (fallback: generic dependsOn names)"
      ansible.builtin.set_fact:
        comp_deps_map: >-
          {%- set m = {} -%}
          {%- for c in components -%}
            {%- set deps = [] -%}
            {%- for d in (c.dependsOn | default([])) -%}
              {%- if d is string -%}
                {%- set _ = deps.append(d) -%}
              {%- elif d.componentName is defined and d.componentName -%}
                {%- set _ = deps.append(d.componentName) -%}
              {%- endif -%}
            {%- endfor -%}
            {%- set _ = m.update({ (c.name): (deps | unique) }) -%}
          {%- endfor -%}
          {{ m }}
      when: not (has_dep_actions | bool)

    - name: Initialize START/HEALTH level computation state
      ansible.builtin.set_fact:
        _levels: []
        _done: []
        _remaining: "{{ components_names | list }}"

    - name: Iteratively compute START/HEALTH dependency levels
      ansible.builtin.include_tasks: roles/deploy_service/tasks/compute_levels_step.yml
      loop: "{{ range(0, (components_names | length) + 1) | list }}"
      loop_control:
        label: "start-levels iteration {{ item }}"

    - name: Assert START/HEALTH dependency graph is acyclic
      ansible.builtin.assert:
        that: (_remaining | length) == 0
        fail_msg: >-
          Unresolvable dependencies detected. Remaining components: {{ _remaining }}. Check execplan.yml for cycles or missing names.

    - name: Compose yum repo flags
      ansible.builtin.set_fact:
        yum_repo_flags: >-
          {%- set flags = [] -%}
          {%- if options.DISABLEREPO | default('') | trim -%}
            {%- set _ = flags.append('--disablerepo=' ~ (options.DISABLEREPO | trim)) -%}
          {%- endif -%}
          {%- if options.ENABLEREPO | default('') | trim -%}
            {%- set _ = flags.append('--enablerepo=' ~ (options.ENABLEREPO | trim)) -%}
          {%- endif -%}
          {{ flags | join(' ') }}

    # Pre-resolve Artifactory GAVC URLs (cache on localhost)
    - name: Normalize Artifactory vars for cache
      ansible.builtin.set_fact:
        _art_url: "{{ artifactory_url | default('https://artifactory.intcx.net/artifactory') }}"
        _art_tok: "{{ artifactory_token | default(lookup('env','ARTIFACTORY_TOKEN') | default(artifactory_password | default(''), true)) }}"

    - name: Build list of unique GAVC keys
      ansible.builtin.set_fact:
        _gavc_keys: >-
          {%- set ks = [] -%}
          {%- for comp in components | default([]) -%}
            {%- for cont in comp.containers | default([]) -%}
              {%- set g = cont.groupId | default('') -%}
              {%- set a = cont.artifactId | default(cont.name | default('')) -%}
              {%- set v = cont.version | default('') -%}
              {%- set p = (cont.type | default('') | lower) -%}
              {%- if g and a and v and p -%}
                {%- set _ = ks.append(g ~ ':' ~ a ~ ':' ~ v ~ ':' ~ p) -%}
              {%- endif -%}
            {%- endfor -%}
          {%- endfor -%}
          {{ ks | unique }}

    - name: Initialize Artifactory URL cache
      ansible.builtin.set_fact:
        final_url_cache: {}

    - name: Query Artifactory for GAVC keys
      ansible.builtin.uri:
        url: "{{ _art_url }}/api/search/gavc?g={{ (item.split(':')[0]) | urlencode }}&a={{ (item.split(':')[1]) | urlencode }}&v={{ (item.split(':')[2]) | urlencode }}&p={{ (item.split(':')[3]) | urlencode }}"
        method: GET
        headers:
          Authorization: "Bearer {{ _art_tok }}"
        return_content: true
      register: _gavc_cache_resp
      loop: "{{ _gavc_keys }}"
      when: (_gavc_keys | length) > 0 and not (ansible_check_mode | default(false))
      retries: 3
      delay: 2
      until: _gavc_cache_resp.status | default(0) == 200
      changed_when: false

    - name: Build final_url_cache from responses
      ansible.builtin.set_fact:
        final_url_cache: >-
          {%- set m = {} -%}
          {%- for r in (_gavc_cache_resp.results | default([])) -%}
            {%- set k = r.item -%}
            {%- set p = (k.split(':')[3]) -%}
            {%- set url = (r.json.results | default([]) | map(attribute='uri') | select('search','\\.' ~ p ~ '$') | map('regex_replace','/api/storage','') | list | first) -%}
            {%- set _ = m.update({ k: (url | default('')) }) -%}
          {%- endfor -%}
          {{ m }}
      when: _gavc_cache_resp is defined and not (ansible_check_mode | default(false))

    - name: Debug components structure before serverFilters extraction
      ansible.builtin.debug:
        msg: |
          🔍 COMPONENTS STRUCTURE DEBUG:
          
          Total components: {{ components | length }}
          Components type: {{ components | type_debug }}
          
          First few components:
          {% for comp in components[:3] %}
          
          Component {{ loop.index }}:
            Type: {{ comp | type_debug }}
            {% if comp is mapping %}
            Keys: {{ comp.keys() | list }}
            Name: {{ comp.name | default('NO NAME') }}
            ServerFilters: {{ comp.serverFilters | default('NO SERVERFILTERS') }}
            {% else %}
            Content: {{ comp }}
            {% endif %}
          {% endfor %}
      when: (options.DEBUG | default(false)) | bool

    - name: Build dynamic host list from serverFilters
      ansible.builtin.set_fact:
        dynamic_hosts: >-
          {%- set hosts = [] -%}
          {%- for comp in components -%}
            {%- if comp is mapping and comp.serverFilters is defined -%}
              {%- for host in (comp.serverFilters | default([])) -%}
                {%- if host not in hosts -%}
                  {%- set _ = hosts.append(host) -%}
                {%- endif -%}
              {%- endfor -%}
            {%- endif -%}
          {%- endfor -%}
          {{ hosts }}

    - name: Debug extracted dynamic hosts
      ansible.builtin.debug:
        msg: |
          🔍 DYNAMIC HOSTS EXTRACTION RESULTS:
          
          Total hosts found: {{ dynamic_hosts | length }}
          Host list: {{ dynamic_hosts }}
      when: (options.DEBUG | default(false)) | bool

    - name: Fail if no hosts
      ansible.builtin.assert:
        that: dynamic_hosts | length > 0
        fail_msg: "No hosts found in execplan.yml."

    - name: Build per-host phase map (STOP/UNINSTALL/DOWNLOAD/INSTALL/START/HEALTH_CHECK)
      ansible.builtin.set_fact:
        host_phase_map: >-
          {%- set out = {} -%}
          {%- for comp in components | default([]) -%}
            {%- set phases = (comp.lifecycle | default([])) -%}
            {%- set do_install = ('INSTALL' in phases) or ('DOWNLOAD' in phases) -%}
            {%- for h in (comp.serverFilters | default([])) -%}
              {%- if h not in out -%}
                {%- set _ = out.update({h: {'STOP':[], 'UNINSTALL':[], 'DOWNLOAD':[], 'INSTALL':[], 'START':[], 'HEALTH_CHECK':[]}}) -%}
              {%- endif -%}
              {%- for ph in phases -%}
                {%- if out[h][ph] is defined -%}
                  {%- set _ = out[h][ph].append(comp) -%}
                {%- endif -%}
              {%- endfor -%}
              {%- if do_install and ('INSTALL' not in phases) -%}
                {%- set _ = out[h]['INSTALL'].append(comp) -%}
              {%- endif -%}

              {#- Dependency-driven injections: for dependsOn entries where orchestrationOnly is absent/false,
                 ensure the dependsOnAction is scheduled for the dependency on applicable hosts. -#}
              {%- for d in (comp.dependsOn | default([])) -%}
                {%- set dn = d.componentName | default('') -%}
                {%- set dep = (components | selectattr('name','equalto', dn) | list | first) -%}
                {%- set dep_action = d.dependsOnAction | default('') -%}
                {%- set dep_hosts = (dep.serverFilters | default([])) if dep is defined else [] -%}
                {%- set filter_ok = (d.serverFilter is not defined) or (d.serverFilter is sequence and (h in d.serverFilter)) -%}
                {%- set host_ok = h in dep_hosts -%}
                {%- if dn and dep is defined and (d.orchestrationOnly is not defined) and filter_ok and host_ok -%}
                  {#- helper lists of existing names to avoid duplicates -#}
                  {%- set names_dl = (out[h]['DOWNLOAD'] | map(attribute='name') | list) -%}
                  {%- set names_in = (out[h]['INSTALL']  | map(attribute='name') | list) -%}
                  {%- set names_st = (out[h]['START']    | map(attribute='name') | list) -%}
                  {%- set names_hl = (out[h]['HEALTH_CHECK'] | map(attribute='name') | list) -%}
                  {%- set names_un = (out[h]['UNINSTALL'] | map(attribute='name') | list) -%}
                  {%- if dep_action == 'INSTALL' -%}
                    {%- if dep.name not in names_dl -%}
                      {%- set _ = out[h]['DOWNLOAD'].append(dep) -%}
                    {%- endif -%}
                    {%- if dep.name not in names_in -%}
                      {%- set _ = out[h]['INSTALL'].append(dep) -%}
                    {%- endif -%}
                  {%- elif dep_action == 'START' -%}
                    {%- if dep.name not in names_st -%}
                      {%- set _ = out[h]['START'].append(dep) -%}
                    {%- endif -%}
                  {%- elif dep_action == 'HEALTH_CHECK' -%}
                    {#- For a health dependency, also ensure START is present to make health meaningful -#}
                    {%- if dep.name not in names_st -%}
                      {%- set _ = out[h]['START'].append(dep) -%}
                    {%- endif -%}
                    {%- if dep.name not in names_hl -%}
                      {%- set _ = out[h]['HEALTH_CHECK'].append(dep) -%}
                    {%- endif -%}
                  {%- elif dep_action == 'UNINSTALL' -%}
                    {%- if dep.name not in names_un -%}
                      {%- set _ = out[h]['UNINSTALL'].append(dep) -%}
                    {%- endif -%}
                  {%- endif -%}
                {%- endif -%}
              {%- endfor -%}
            {%- endfor -%}
          {%- endfor -%}
          {{ out }}

    - name: Register dynamic hosts with per-host variables
      ansible.builtin.add_host:
        name: "{{ h }}"
        groups: dynamic_hosts
        phase_map: "{{ host_phase_map[h] | default({'STOP':[], 'UNINSTALL':[], 'DOWNLOAD':[], 'INSTALL':[], 'START':[], 'HEALTH_CHECK':[]}) }}"
        no_dep_components: "{{ no_dep_components }}"
        dep_components_in_order: "{{ dep_components_in_order }}"
        component_levels_install: "{{ component_levels_install | default([]) }}"
        component_levels: "{{ _levels }}"
        timeout: "{{ timeout | default(30, true) }}"
        retry: "{{ retry | default(5, true) }}"
        retryDelay: "{{ retryDelay | default(2, true) }}"
        yum_repo_flags: "{{ yum_repo_flags }}"
        options: "{{ options }}"
        proxy_env:
          http_proxy: "http://{{ options.PROXY | regex_replace('^(http|https)://', '') }}"
          https_proxy: "http://{{ options.PROXY | regex_replace('^(http|https)://', '') }}"
        artifactory_url: "{{ artifactory_url | default('https://artifactory.intcx.net/artifactory') }}"
        artifactory_token: "{{ artifactory_token | default(lookup('env','ARTIFACTORY_TOKEN') | default(artifactory_password | default(''), true)) }}"
      loop: "{{ dynamic_hosts }}"
      loop_control: { loop_var: h }

# ───────────────────────────────────────────────────────────────
# Play 2 — STOP (parallel no-deps, then sequential remainder)
# ───────────────────────────────────────────────────────────────
- name: STOP phase (parallel roots, then sequential)
  hosts: dynamic_hosts
  gather_facts: false
  strategy: free
  any_errors_fatal: true
  tasks:
    - ansible.builtin.setup: { gather_subset: [min] }

    - name: Stop (Linux) — parallel dependency-free components
      when:
        - (ansible_facts.os_family | default('')) not in ['Windows','windows']
        - (hostvars[inventory_hostname].phase_map['STOP'] | selectattr('name','in', no_dep_components) | list | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: stop_only_linux.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['STOP'] | selectattr('name','in', no_dep_components) | list }}"

    - name: Stop (Windows) — parallel dependency-free components
      when:
        - (ansible_facts.os_family | default('')) in ['Windows','windows']
        - (hostvars[inventory_hostname].phase_map['STOP'] | selectattr('name','in', no_dep_components) | list | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: stop_only_windows.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['STOP'] | selectattr('name','in', no_dep_components) | list }}"

    - name: Stop — sequential remainder (component-ordered)
      ansible.builtin.include_tasks: roles/deploy_service/tasks/wrapped_phase.yml
      vars:
        phase: STOP
        component_name: "{{ comp_name }}"
      loop: "{{ hostvars[inventory_hostname].phase_map['STOP'] | rejectattr('name','in', no_dep_components) | map(attribute='name') | list }}"
      loop_control:
        loop_var: comp_name
        label: "{{ comp_name }}"

# ───────────────────────────────────────────────────────────────
# Play 3 — UNINSTALL (parallel no-deps, then sequential remainder)
# ───────────────────────────────────────────────────────────────
- name: UNINSTALL phase (parallel roots, then sequential)
  hosts: dynamic_hosts
  gather_facts: false
  strategy: free
  any_errors_fatal: true
  tasks:
    - ansible.builtin.setup: { gather_subset: [min] }

    - name: Uninstall — parallel dependency-free components (Linux)
      when:
        - (ansible_facts.os_family | default('')) not in ['Windows','windows']
        - (hostvars[inventory_hostname].phase_map['UNINSTALL'] | selectattr('name','in', no_dep_components) | list | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: host_uninstall_batch.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['UNINSTALL'] | selectattr('name','in', no_dep_components) | list }}"

    - name: Uninstall — parallel dependency-free components (Windows)
      when:
        - (ansible_facts.os_family | default('')) in ['Windows','windows']
        - (hostvars[inventory_hostname].phase_map['UNINSTALL'] | selectattr('name','in', no_dep_components) | list | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: host_uninstall_batch_windows.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['UNINSTALL'] | selectattr('name','in', no_dep_components) | list }}"

    - name: Uninstall — sequential remainder (component-ordered)
      ansible.builtin.include_tasks: roles/deploy_service/tasks/wrapped_phase.yml
      vars:
        phase: UNINSTALL
        component_name: "{{ comp_name }}"
      loop: "{{ hostvars[inventory_hostname].phase_map['UNINSTALL'] | rejectattr('name','in', no_dep_components) | map(attribute='name') | list }}"
      loop_control:
        loop_var: comp_name
        label: "{{ comp_name }}"

# ───────────────────────────────────────────────────────────────
# Play 4 — DOWNLOAD (parallel no-deps, then sequential remainder)
# ───────────────────────────────────────────────────────────────
- name: DOWNLOAD phase (parallel roots, then sequential)
  hosts: dynamic_hosts
  gather_facts: false
  strategy: free
  tasks:
    - ansible.builtin.setup: { gather_subset: [min] }

    - name: Download artifacts — parallel dependency-free components
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: service_download.yml
      loop: "{{ hostvars[inventory_hostname].phase_map['DOWNLOAD'] | selectattr('name','in', no_dep_components) | list }}"
      loop_control: { loop_var: service, label: "{{ service.name }}" }
      vars:
        artifactory_url:   "{{ hostvars[inventory_hostname].artifactory_url }}"
        artifactory_token: "{{ hostvars[inventory_hostname].artifactory_token }}"

    - name: Download artifacts — sequential remainder (component-ordered)
      ansible.builtin.include_tasks: roles/deploy_service/tasks/wrapped_phase.yml
      vars:
        phase: DOWNLOAD
        component_name: "{{ comp_name }}"
      loop: "{{ hostvars[inventory_hostname].phase_map['DOWNLOAD'] | rejectattr('name','in', no_dep_components) | map(attribute='name') | list }}"
      loop_control:
        loop_var: comp_name
        label: "{{ comp_name }}"

# ───────────────────────────────────────────────────────────────
# Play 4a — Validate DOWNLOAD phase results
# ───────────────────────────────────────────────────────────────
- name: Validate DOWNLOAD phase results
  hosts: localhost
  gather_facts: false
  vars:
    real_hosts: "{{ groups['dynamic_hosts'] | default([]) }}"
  tasks:
    - name: Collect download failure stats from all hosts
      ansible.builtin.set_fact:
        download_failure_count: >-
          {{
            real_hosts
            | map('extract', hostvars, 'download_summary')
            | map('default', {'failed_artifacts':[]})
            | map(attribute='failed_artifacts')
            | map('length')
            | sum
          }}

    - name: Display download failure summary
      ansible.builtin.debug:
        msg:
          total_download_failures: "{{ download_failure_count }}"
          summary: "{{ download_failure_count }} download failures detected across infrastructure"

    - name: Display detailed failure diagnostics for each failed artifact
      ansible.builtin.debug:
        msg: "{{ item.detailed_diagnostics }}"
      loop: >-
        {{
          real_hosts
          | map('extract', hostvars, 'download_summary')
          | map('default', {'failed_artifacts':[]})
          | map(attribute='failed_artifacts')
          | list
          | sum(start=[])
        }}
      loop_control:
        label: "{{ item.artifact }} on {{ item.host }}"
      when: download_failure_count | int > 0

    - name: Fail playbook if any downloads failed
      ansible.builtin.fail:
        msg: |
          ORCHESTRATION FAILURE - DOWNLOAD PHASE FAILED
          ===============================================
          
          {{ download_failure_count }} download failure(s) detected across the infrastructure.
          
          Strategy 'free' allows parallel execution for performance, but orchestration 
          requires ALL downloads to succeed before proceeding to installation phases.
          
          FAILED ARTIFACTS SUMMARY:
          {% for host in real_hosts %}
          {%- set host_failures = hostvars[host].download_summary.failed_artifacts | default([]) %}
          {%- if host_failures | length > 0 %}
          
          Host: {{ host }}
          {%- for failure in host_failures %}
          - {{ failure.artifact }}
            Error: {{ failure.error_summary }}
            Search Status: {{ failure.search_status }}
            Results Found: {{ failure.search_results_count }}
          {%- endfor %}
          {%- endif %}
          {%- endfor %}
          
          RESOLUTION STEPS:
          1. Review detailed diagnostics above for each failed artifact
          2. Verify artifacts exist in Artifactory with exact coordinates
          3. Check repository permissions and authentication
          4. Ensure network connectivity to Artifactory
          5. Fix artifact configurations in execplan.yml if coordinates are incorrect
          
          All downloads must succeed for orchestration to continue.
      when: (download_failure_count | int) > 0

# ───────────────────────────────────────────────────────────────
# Play 4 — INSTALL roots (parallel, level 0 only)
# ───────────────────────────────────────────────────────────────
- name: INSTALL roots (level 0, parallel)
  hosts: dynamic_hosts
  gather_facts: false
  strategy: free
  tasks:
    - ansible.builtin.setup: { gather_subset: [min] }

    - name: Install root components (Linux)
      when:
        - (ansible_facts.os_family | default('')) not in ['Windows','windows']
        - hostvars['localhost'].has_install_actions | default(false)
        - ((hostvars[inventory_hostname].component_levels_install | default([]) | first | default([])) | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: host_install_batch.yml
      vars:
        phase_services: >-
          {{
            hostvars[inventory_hostname].phase_map['INSTALL']
            | selectattr('name','in', (hostvars[inventory_hostname].component_levels_install | default([]) | first | default([])))
            | list
          }}
        yum_repo_flags: "{{ hostvars[inventory_hostname].yum_repo_flags }}"
        options: "{{ hostvars[inventory_hostname].options }}"

    - name: Install root components (Windows)
      when:
        - (ansible_facts.os_family | default('')) in ['Windows','windows']
        - hostvars['localhost'].has_install_actions | default(false)
        - ((hostvars[inventory_hostname].component_levels_install | default([]) | first | default([])) | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: host_install_batch_windows.yml
      vars:
        phase_services: >-
          {{
            hostvars[inventory_hostname].phase_map['INSTALL']
            | selectattr('name','in', (hostvars[inventory_hostname].component_levels_install | default([]) | first | default([])))
            | list
          }}

# ───────────────────────────────────────────────────────────────
# Play 4a — INSTALL (legacy: parallel roots, then sequential remainder)
# ───────────────────────────────────────────────────────────────
- name: INSTALL phase (legacy root+sequential)
  hosts: dynamic_hosts
  gather_facts: false
  strategy: free
  any_errors_fatal: true
  tasks:
    - ansible.builtin.setup: { gather_subset: [min] }

    - name: Host-wide install (Linux) — legacy roots
      when:
        - not (hostvars['localhost'].has_install_actions | default(false))
        - (ansible_facts.os_family | default('')) not in ['Windows','windows']
        - (hostvars[inventory_hostname].phase_map['INSTALL'] | selectattr('name','in', no_dep_components) | list | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: host_install_batch.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['INSTALL'] | selectattr('name','in', no_dep_components) | list }}"
        yum_repo_flags: "{{ hostvars[inventory_hostname].yum_repo_flags }}"
        options: "{{ hostvars[inventory_hostname].options }}"

    - name: Host-wide install (Windows) — legacy roots
      when:
        - not (hostvars['localhost'].has_install_actions | default(false))
        - (ansible_facts.os_family | default('')) in ['Windows','windows']
        - (hostvars[inventory_hostname].phase_map['INSTALL'] | selectattr('name','in', no_dep_components) | list | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: host_install_batch_windows.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['INSTALL'] | selectattr('name','in', no_dep_components) | list }}"

# ───────────────────────────────────────────────────────────────
# Play 4b — START + HEALTH (roots only, parallel)
# ───────────────────────────────────────────────────────────────
- name: ROOT START + HEALTH (parallel for no-deps)
  hosts: dynamic_hosts
  gather_facts: false
  strategy: free
  any_errors_fatal: true
  tasks:
    - ansible.builtin.setup: { gather_subset: [min] }

    - name: Start root services (Linux)
      when:
        - (ansible_facts.os_family | default('')) not in ['Windows','windows']
        - (hostvars[inventory_hostname].phase_map['START'] | selectattr('name','in', no_dep_components) | list | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: start_only_linux.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['START'] | selectattr('name','in', no_dep_components) | list }}"

    - name: Start root services (Windows)
      when:
        - (ansible_facts.os_family | default('')) in ['Windows','windows']
        - (hostvars[inventory_hostname].phase_map['START'] | selectattr('name','in', no_dep_components) | list | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: start_only_windows.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['START'] | selectattr('name','in', no_dep_components) | list }}"

    - name: Health-check root services (Linux)
      when:
        - (ansible_facts.os_family | default('')) not in ['Windows','windows']
        - (hostvars[inventory_hostname].phase_map['HEALTH_CHECK'] | selectattr('name','in', no_dep_components) | list | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: health_only_linux.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['HEALTH_CHECK'] | selectattr('name','in', no_dep_components) | list }}"

    - name: Health-check root services (Windows)
      when:
        - (ansible_facts.os_family | default('')) in ['Windows','windows']
        - (hostvars[inventory_hostname].phase_map['HEALTH_CHECK'] | selectattr('name','in', no_dep_components) | list | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: health_only_windows.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['HEALTH_CHECK'] | selectattr('name','in', no_dep_components) | list }}"



# ───────────────────────────────────────────────────────────────
# Play 4d — INSTALL (level-gated remainder)
# ───────────────────────────────────────────────────────────────
- name: INSTALL remainder (level-gated)
  hosts: dynamic_hosts
  gather_facts: false
  any_errors_fatal: true
  tasks:
    - ansible.builtin.setup: { gather_subset: [min] }

    - name: Prepare INSTALL levels for this host
      ansible.builtin.set_fact:
        _levels_install_host: "{{ hostvars[inventory_hostname].component_levels_install | default([]) }}"

    - name: Install services level-by-level (Linux)
      when:
        - hostvars['localhost'].has_install_actions | default(false)
        - (ansible_facts.os_family | default('')) not in ['Windows','windows']
        - (_levels_install_host | length) > 0
        - (level_index | default(0)) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: host_install_batch.yml
      vars:
        phase_services: >-
          {{
            hostvars[inventory_hostname].phase_map['INSTALL']
            | selectattr('name','in', level_group)
            | list
          }}
        yum_repo_flags: "{{ hostvars[inventory_hostname].yum_repo_flags }}"
        options: "{{ hostvars[inventory_hostname].options }}"
      loop: "{{ _levels_install_host }}"
      loop_control:
        loop_var: level_group
        index_var: level_index
        label: "level={{ level_index }}"

    - name: Install services level-by-level (Windows)
      when:
        - hostvars['localhost'].has_install_actions | default(false)
        - (ansible_facts.os_family | default('')) in ['Windows','windows']
        - (_levels_install_host | length) > 0
        - (level_index | default(0)) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: host_install_batch_windows.yml
      vars:
        phase_services: >-
          {{
            hostvars[inventory_hostname].phase_map['INSTALL']
            | selectattr('name','in', level_group)
            | list
          }}
      loop: "{{ _levels_install_host }}"
      loop_control:
        loop_var: level_group
        index_var: level_index
        label: "level={{ level_index }}"

    - name: Install — legacy remainder (component-ordered, Linux)
      ansible.builtin.include_tasks: roles/deploy_service/tasks/wrapped_phase.yml
      vars:
        phase: INSTALL
        component_name: "{{ comp_name }}"
      loop: "{{ hostvars[inventory_hostname].phase_map['INSTALL'] | rejectattr('name','in', no_dep_components) | map(attribute='name') | list }}"
      loop_control:
        loop_var: comp_name
        label: "{{ comp_name }}"
      when:
        - not (hostvars['localhost'].has_install_actions | default(false))
        - (ansible_facts.os_family | default('')) not in ['Windows','windows']

    - name: Install — legacy remainder (component-ordered, Windows)
      ansible.builtin.include_tasks: roles/deploy_service/tasks/wrapped_phase.yml
      vars:
        phase: INSTALL
        component_name: "{{ comp_name }}"
      loop: "{{ hostvars[inventory_hostname].phase_map['INSTALL'] | rejectattr('name','in', no_dep_components) | map(attribute='name') | list }}"
      loop_control:
        loop_var: comp_name
        label: "{{ comp_name }}"
      when:
        - not (hostvars['localhost'].has_install_actions | default(false))
        - (ansible_facts.os_family | default('')) in ['Windows','windows']
# ───────────────────────────────────────────────────────────────
# Play 5 — START + HEALTH gated by dependency levels
# ───────────────────────────────────────────────────────────────
- name: START + HEALTH (level-gated)
  hosts: dynamic_hosts
  gather_facts: false
  any_errors_fatal: true
  tasks:
    - ansible.builtin.setup: { gather_subset: [min] }

    - name: Prepare component levels for this host
      ansible.builtin.set_fact:
        _levels_host: "{{ hostvars[inventory_hostname].component_levels | default([]) }}"

    - name: Start services level-by-level (Linux)
      when:
        - (ansible_facts.os_family | default('')) not in ['Windows','windows']
        - (_levels_host | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: start_only_linux.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['START'] | selectattr('name','in', level_group) | rejectattr('name','in', no_dep_components) | list }}"
      loop: "{{ _levels_host }}"
      loop_control:
        loop_var: level_group
        index_var: level_index
        label: "level={{ level_index }}"

    - name: Start services level-by-level (Windows)
      when:
        - (ansible_facts.os_family | default('')) in ['Windows','windows']
        - (_levels_host | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: start_only_windows.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['START'] | selectattr('name','in', level_group) | rejectattr('name','in', no_dep_components) | list }}"
      loop: "{{ _levels_host }}"
      loop_control:
        loop_var: level_group
        index_var: level_index
        label: "level={{ level_index }}"

    - name: Health-check level-by-level (Linux)
      when:
        - (ansible_facts.os_family | default('')) not in ['Windows','windows']
        - (_levels_host | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: health_only_linux.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['HEALTH_CHECK'] | selectattr('name','in', level_group) | rejectattr('name','in', no_dep_components) | list }}"
      loop: "{{ _levels_host }}"
      loop_control:
        loop_var: level_group
        index_var: level_index
        label: "level={{ level_index }}"

    - name: Health-check level-by-level (Windows)
      when:
        - (ansible_facts.os_family | default('')) in ['Windows','windows']
        - (_levels_host | length) > 0
      ansible.builtin.include_role:
        name: deploy_service
        tasks_from: health_only_windows.yml
      vars:
        phase_services: "{{ hostvars[inventory_hostname].phase_map['HEALTH_CHECK'] | selectattr('name','in', level_group) | rejectattr('name','in', no_dep_components) | list }}"
      loop: "{{ _levels_host }}"
      loop_control:
        loop_var: level_group
        index_var: level_index
        label: "level={{ level_index }}"

# Play 6 removed; Health checks are performed within Play 5 per level

# ───────────────────────────────────────────────────────────────
# Play 7 — Aggregate results
# ───────────────────────────────────────────────────────────────
- name: POST_DEPLOY cleanup and SE Tools
  hosts: dynamic_hosts
  gather_facts: false
  strategy: free
  tasks:
    - ansible.builtin.setup: { gather_subset: [min] }

    - name: Clear prior host errors so post-deploy still runs
      meta: clear_host_errors

    - block:
        - name: Run post_deploy role (SE Tools + cleanup)
          ansible.builtin.include_role:
            name: post_deploy
      rescue:
        - name: Report post_deploy failure but continue
          ansible.builtin.debug:
            msg: "post_deploy failed on {{ inventory_hostname }} — continuing to next host"
      always:
        - name: Mark post_deploy attempted
          ansible.builtin.debug:
            msg: "post_deploy attempted on {{ inventory_hostname }}"
