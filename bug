# roles/deploy_service/tasks/host_install_batch.yml

# 1) Collect RPMs + hooks
- name: Collect RPM paths and INSTALL hooks (Linux)
  ansible.builtin.set_fact:
    _rpm_paths_from_plan: >-
      {{
        phase_services | map(attribute='containers') | sum(start=[])
        | selectattr('type','defined') | selectattr('type','equalto','RPM')
        | selectattr('__dest','defined')
        | map(attribute='__dest') | list
      }}
    _install_before: >-
      {{
        phase_services | map(attribute='actionCommands') | sum(start=[])
        | selectattr('action','equalto','INSTALL')
        | selectattr('runStage','equalto','BEFORE')
        | map(attribute='command') | map('trim') | reject('equalto','') | list
      }}
    _install_after: >-
      {{
        phase_services | map(attribute='actionCommands') | sum(start=[])
        | selectattr('action','equalto','INSTALL')
        | selectattr('runStage','equalto','AFTER')
        | map(attribute='command') | map('trim') | reject('equalto','') | list
      }}

- name: Prefer RPM paths captured during DOWNLOAD (if any)
  ansible.builtin.set_fact:
    _rpm_paths: "{{ (downloaded_rpms | default([]) + _rpm_paths_from_plan) | unique }}"
  when: _rpm_paths is not defined

# 2) Proxy / repo flags
- name: Normalize proxy value
  ansible.builtin.set_fact:
    _proxy_val: "{{ (options.PROXY | default('') | string) | trim }}"

- name: Build proxy flag and repo flags
  ansible.builtin.set_fact:
    _proxy_flag: "{{ (((_proxy_val | default('') | string) | trim | length) > 0) | ternary('--setopt=proxy=' ~ _proxy_val, '') }}"
    _repo_flags: "{{ (yum_repo_flags | default('') | string) | trim }}"

# 3) Derive package names / file NEVRs from the RPMs
- name: Derive package NAMES from RPM files
  ansible.builtin.shell: 'rpm -qp --qf "%{NAME}\n" "{{ item }}"'
  args: { executable: /bin/bash }
  loop: "{{ _rpm_paths }}"
  register: _rpm_qp_name
  failed_when: false
  changed_when: false
  when: (_rpm_paths | length) > 0

- name: Derive package NEVRs from RPM files
  ansible.builtin.shell: 'rpm -qp --qf "%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}\n" "{{ item }}"'
  args: { executable: /bin/bash }
  loop: "{{ _rpm_paths }}"
  register: _rpm_qp_nevr
  failed_when: false
  changed_when: false
  when: (_rpm_paths | length) > 0

- name: Collect unique package names and file NEVRs
  ansible.builtin.set_fact:
    _rpm_pkg_names: >-
      {{
        (_rpm_qp_name.results | default([]))
        | map(attribute='stdout') | map('trim') | reject('equalto','')
        | list | unique
      }}
    _rpm_file_nevrs: >-
      {{
        (_rpm_qp_nevr.results | default([]))
        | map(attribute='stdout') | map('trim') | reject('equalto','')
        | list | unique
      }}
  when: (_rpm_paths | length) > 0

# 4) Find installed packages (names and NEVRs)
- name: Check which package names are already installed
  ansible.builtin.shell: "rpm -q --quiet {{ item }}"
  args: { executable: /bin/bash }
  loop: "{{ _rpm_pkg_names | default([]) }}"
  register: _rpm_q
  failed_when: false
  changed_when: false
  when: (_rpm_pkg_names | default([]) | length) > 0

- name: Build list of installed package names
  ansible.builtin.set_fact:
    _rpm_installed_names: "{{ _rpm_q.results | selectattr('rc','equalto',0) | map(attribute='item') | list }}"
  when: (_rpm_pkg_names | default([]) | length) > 0

- name: Get installed NEVRs for those names
  ansible.builtin.shell: "rpm -q {{ item }}"
  args: { executable: /bin/bash }
  loop: "{{ _rpm_installed_names | default([]) }}"
  register: _rpm_q_nevr
  failed_when: false
  changed_when: false
  when: (_rpm_installed_names | default([]) | length) > 0

- name: Collect installed NEVRs (unique)
  ansible.builtin.set_fact:
    _rpm_installed_nevrs: >-
      {{
        (_rpm_q_nevr.results | default([]))
        | map(attribute='stdout_lines') | list | sum(start=[])
        | map('trim') | reject('equalto','') | list | unique
      }}
  when: (_rpm_installed_names | default([]) | length) > 0

# 5) Build command strings
- name: Build rpm join lists
  ansible.builtin.set_fact:
    _rpm_joined: >-
      {{ (_rpm_paths | default([])) | map('regex_replace','^','"') | map('regex_replace','$','"') | join(' ') }}

- name: Choose removal candidates (NEVRs preferred, else names)
  ansible.builtin.set_fact:
    _remove_candidates: >-
      {{ (_rpm_installed_nevrs | default([])) if ((_rpm_installed_nevrs | default([]) | length) > 0) else (_rpm_pkg_names | default([])) }}

- name: Join removal candidate list (no quotes, no empties)
  ansible.builtin.set_fact:
    _remove_joined: "{{ (_remove_candidates | default([])) | map('trim') | reject('equalto','') | list | join(' ') }}"

- name: Build remove + install/reinstall commands (yum only)
  ansible.builtin.set_fact:
    _remove_cmd: >-
      {% if (_remove_joined | length) == 0 -%}
      echo "No packages to remove on {{ inventory_hostname }}."
      {%- else -%}
      /usr/bin/sudo rpm -e --nodeps {{ _remove_joined }} || /usr/bin/sudo rpm -e --nodeps --noscripts {{ _remove_joined }} || true
      {%- endif %}
    _yum_install_cmd: >-
      /usr/bin/sudo yum -y {{ _proxy_flag | default('') }} {{ _repo_flags | default('') }} install {{ _rpm_joined | default('') }}
    _yum_reinstall_cmd: >-
      /usr/bin/sudo yum -y {{ _proxy_flag | default('') }} {{ _repo_flags | default('') }} reinstall {{ _rpm_joined | default('') }}

# --- TEMP DEBUG: show exactly what we’ll do (including proxy propagation) ----
- name: "DEBUG (temp): planned remove/install commands + inputs"
  ansible.builtin.debug:
    msg: |
      proxy_flag: {{ _proxy_flag }}
      repo_flags: {{ _repo_flags }}
      rpm_paths: {{ _rpm_paths | to_nice_json }}
      rpm_file_nevrs: {{ _rpm_file_nevrs | default([]) | to_nice_json }}
      rpm_pkg_names: {{ _rpm_pkg_names | default([]) | to_nice_json }}
      rpm_installed_names: {{ _rpm_installed_names | default([]) | to_nice_json }}
      rpm_installed_nevrs: {{ _rpm_installed_nevrs | default([]) | to_nice_json }}
      remove_candidates: {{ _remove_candidates | default([]) | to_nice_json }}
      remove_joined: {{ _remove_joined }}
      remove_cmd: {{ _remove_cmd }}
      yum_install_cmd: {{ _yum_install_cmd }}
      yum_reinstall_cmd: {{ _yum_reinstall_cmd }}
  when: options.DEBUG | default(false)

# ── CHECK MODE: only show what we would do ───────────────────────────────────
- block:
    - name: (check) BEFORE INSTALL hooks to run
      ansible.builtin.debug: { var: _install_before }
      when: _install_before | length > 0

    - name: (check) Would run remove + yum install (with reinstall fallback)
      ansible.builtin.debug:
        msg: |
          {{ _remove_cmd }} &&
          if rpm -q --quiet {{ (_rpm_pkg_names | default([])) | join(' ') }}; then
            echo "Packages still present -> would run: {{ _yum_reinstall_cmd }}";
          else
            echo "Packages removed -> would run: {{ _yum_install_cmd }}";
          fi

    - name: (check) AFTER INSTALL hooks to run
      ansible.builtin.debug: { var: _install_after }
      when: _install_after | length > 0

    - name: Record simulated install summary (Linux, check mode)
      ansible.builtin.set_stats:
        aggregate: true
        data:
          install_summary:
            host: "{{ inventory_hostname }}"
            success_artifacts: []
            failed_artifacts: []
  when: ansible_check_mode | default(false)

# ── REAL RUN ─────────────────────────────────────────────────────────────────
- block:
    - name: BEFORE INSTALL hooks
      ansible.builtin.shell: "{{ item }}"
      args: { executable: /bin/bash }
      loop: "{{ _install_before }}"
      register: _before_out
      failed_when: false
      changed_when: true
      when: _install_before | length > 0

    - name: Skip if no RPMs to install on this host
      ansible.builtin.debug:
        msg: "No RPMs to install on {{ inventory_hostname }}."
      when: _rpm_paths | length == 0

    # Visibility: state before removal
    - name: "DEBUG before-remove: installed state for target names"
      ansible.builtin.shell: |
        for n in {{ (_rpm_pkg_names | default([])) | join(' ') }}; do
          echo "=== rpm -q $n ==="
          rpm -q "$n" || true
        done
      args: { executable: /bin/bash }
      register: _debug_before_remove
      when: (_rpm_pkg_names | default([]) | length) > 0
      changed_when: false
      failed_when: false

    - name: Remove currently-installed packages (NEVRs preferred, fallback to names)
      ansible.builtin.shell: |
        set -x
        {{ _remove_cmd }}
      args: { executable: /bin/bash }
      register: _remove_run
      when: (_remove_joined | length) > 0
      changed_when: true
      failed_when: false

    - name: DEBUG remove result (rc/stdout/stderr)
      ansible.builtin.debug:
        msg: |
          rc: {{ _remove_run.rc | default('n/a') }}
          stdout:
          {{ (_remove_run.stdout | default('')) | indent(2) }}
          stderr:
          {{ (_remove_run.stderr | default('')) | indent(2) }}
      when: _remove_run is defined

    - name: Verify removals (non-fatal check)
      ansible.builtin.shell: |
        rc=0
        for n in {{ (_rpm_pkg_names | default([])) | join(' ') }}; do
          if rpm -q --quiet "$n"; then
            echo "$n still installed"
            rc=1
          fi
        done
        exit $rc
      args: { executable: /bin/bash }
      register: _remove_verify
      when: (_rpm_pkg_names | default([]) | length) > 0
      changed_when: false
      failed_when: false

    - name: DEBUG after-remove verification
      ansible.builtin.debug:
        msg: |
          remove_verify_rc: {{ _remove_verify.rc | default('n/a') }}
          remove_verify_stdout:
          {{ (_remove_verify.stdout | default('')) | indent(2) }}
          remove_verify_stderr:
          {{ (_remove_verify.stderr | default('')) | indent(2) }}
      when: _remove_verify is defined

    # Decide path: install vs reinstall (if removal didn’t take)
    - name: Decide install mode (install vs reinstall)
      ansible.builtin.set_fact:
        _do_reinstall: "{{ (_remove_verify.rc | default(0)) | int != 0 }}"
      when: (_rpm_paths | length) > 0

    - name: Run yum install (fresh, after successful removals)
      ansible.builtin.shell: |
        set -o pipefail
        set -x
        {{ _yum_install_cmd }}
      args: { executable: /bin/bash }
      register: _yum_run
      when: (_rpm_paths | length > 0) and (not _do_reinstall | default(false))
      changed_when: >
        (_rpm_paths | length > 0) and
        ('Nothing to do' not in ((_yum_run.stdout | default('')) + (_yum_run.stderr | default(''))))

    - name: Run yum reinstall (same-version fallback when removal didn’t occur)
      ansible.builtin.shell: |
        set -o pipefail
        set -x
        {{ _yum_reinstall_cmd }}
      args: { executable: /bin/bash }
      register: _yum_run
      when: (_rpm_paths | length > 0) and (_do_reinstall | default(false))
      changed_when: true

    - name: DEBUG install/reinstall result (rc/stdout/stderr)
      ansible.builtin.debug:
        msg: |
          reinstall_mode: {{ _do_reinstall | default(false) }}
          rc: {{ _yum_run.rc | default('n/a') }}
          stdout:
          {{ (_yum_run.stdout | default('')) | indent(2) }}
          stderr:
          {{ (_yum_run.stderr | default('')) | indent(2) }}
      when: _yum_run is defined

    - name: Fail install if yum returned non-zero
      ansible.builtin.fail:
        msg: >-
          Install failed for packages on {{ inventory_hostname }} (rc={{ _yum_run.rc | default('n/a') }}).
          Command: {{ ( _do_reinstall | default(false) ) | ternary(_yum_reinstall_cmd, _yum_install_cmd) }}
          stdout:
          {{ (_yum_run.stdout | default('')) | indent(2) }}
          stderr:
          {{ (_yum_run.stderr | default('')) | indent(2) }}
      when: (_rpm_paths | length > 0) and (_yum_run.rc | default(0)) != 0

    # Final state after install
    - name: "DEBUG after-install: installed state for target names"
      ansible.builtin.shell: |
        for n in {{ (_rpm_pkg_names | default([])) | join(' ') }}; do
          echo "=== rpm -q $n ==="
          rpm -q "$n" || true
        done
      args: { executable: /bin/bash }
      register: _debug_after_install
      when: (_rpm_pkg_names | default([]) | length) > 0
      changed_when: false
      failed_when: false

    - name: Show after-install rpm query results
      ansible.builtin.debug:
        msg: |
          rpm_q_summary (after-install):
          {{ (_debug_after_install.stdout | default('')) | indent(2) }}
      when: _debug_after_install is defined

    - name: AFTER INSTALL hooks
      ansible.builtin.shell: "{{ item }}"
      args: { executable: /bin/bash }
      loop: "{{ _install_after }}"
      register: _after_out
      failed_when: false
      changed_when: true
      when: _install_after | length > 0

    - name: Record install summary (Linux)
      ansible.builtin.set_stats:
        aggregate: true
        data:
          install_summary:
            host: "{{ inventory_hostname }}"
            success_artifacts: "{{ (_rpm_paths | length > 0 and (_yum_run.rc | default(0)) == 0) | ternary(_rpm_paths, []) }}"
            failed_artifacts:  "{{ (_rpm_paths | length > 0 and (_yum_run.rc | default(1)) != 0) | ternary(_rpm_paths, []) }}"
  when: not (ansible_check_mode | default(false))
========================================================================================
# Download all containers for a single service on the current host.
#roles/deploy_service/tasks/service_download.yml
- ansible.builtin.setup: { gather_subset: [min] }
  when: ansible_facts is not defined

- name: Initialize download summary for this service
  ansible.builtin.set_fact:
    download_summary: "{{ download_summary | default({'success_artifacts':[], 'failed_artifacts':[]}) }}"

- name: Reset async job list for this service
  ansible.builtin.set_fact:
    download_async_jobs: []

- name: Build download list
  ansible.builtin.set_fact:
    _dl_list: "{{ service.containers | default([]) }}"

- name: Download each container (check-safe include)
  ansible.builtin.include_tasks: download_artifact.yml
  loop: "{{ _dl_list }}"
  loop_control:
    loop_var: container
    label: "{{ container.artifactId | default(container.name) }}:{{ container.version }}"
  vars:
    art_url:   "https://artifactory.intcx.net/artifactory"
    art_token: "{{ artifactory_password }}"

# After spawning async downloads per container, wait for completion and record RPMs
- name: Wait for all async downloads to finish
  ansible.builtin.async_status:
    jid: "{{ job.ansible_job_id }}"
  register: _dl_wait
  until: _dl_wait.finished
  retries: 450
  delay: 2
  loop: "{{ download_async_jobs | default([]) }}"
  loop_control:
    loop_var: job
    label: "{{ job.dest_path }}"
  when:
    - (download_async_jobs | default([]) | length) > 0
  no_log: "{{ not (options.DEBUG | default(false)) }}"

- name: Build jobId -> dest map
  ansible.builtin.set_fact:
    _dl_id_dest_map: >-
      {%- set m = {} -%}
      {%- for j in (download_async_jobs | default([])) -%}
        {%- set _ = m.update({ (j.ansible_job_id | string): (j.dest_path | default('')) }) -%}
      {%- endfor -%}
      {{ m }}
  when: (download_async_jobs | default([]) | length) > 0

- name: Collate completed RPM downloads
  ansible.builtin.set_fact:
    _dl_completed_rpm_paths: >-
      {%- set out = [] -%}
      {%- for r in (_dl_wait.results | default([])) -%}
        {%- set jid = r.ansible_job_id | string -%}
        {%- set dest = _dl_id_dest_map.get(jid, r.result.dest | default('')) -%}
        {%- if (r.finished | default(false)) and not (r.failed | default(false)) and (dest is search('\\.rpm$')) -%}
          {%- set _ = out.append(dest) -%}
        {%- endif -%}
      {%- endfor -%}
      {{ out | unique }}
  when:
    - _dl_wait is defined
    - (ansible_facts.os_family | default('')) not in ['Windows','windows']
  no_log: "{{ not (options.DEBUG | default(false)) }}"

- name: Record completed RPM paths
  ansible.builtin.set_fact:
    downloaded_rpms: "{{ (downloaded_rpms | default([])) + (_dl_completed_rpm_paths | default([])) | unique }}"
  when: _dl_completed_rpm_paths is defined and (_dl_completed_rpm_paths | length) > 0

- name: DEBUG downloaded RPMs for this host
  ansible.builtin.debug:
    msg: "downloaded_rpms: {{ downloaded_rpms | default([]) | to_nice_json }}"
  when: downloaded_rpms is defined and (downloaded_rpms | length) > 0

=========================================================================================

#roles/deploy_service/tasks/start_only_linux.yml
- name: Build start & hooks (Linux)
  ansible.builtin.set_fact:
    _start_cmds: >-
      {{
        phase_services | map(attribute='containers') | sum(start=[])
        | map(attribute='serviceCommands') | select('defined')
        | map(attribute='start') | reject('equalto', None)
        | map('trim') | reject('equalto','') | list
      }}
    _start_before: >-
      {{
        phase_services | map(attribute='actionCommands') | sum(start=[])
        | selectattr('action','equalto','START')
        | selectattr('runStage','equalto','BEFORE')
        | map(attribute='command') | map('trim') | reject('equalto','') | list
      }}
    _start_after: >-
      {{
        phase_services | map(attribute='actionCommands') | sum(start=[])
        | selectattr('action','equalto','START')
        | selectattr('runStage','equalto','AFTER')
        | map(attribute='command') | map('trim') | reject('equalto','') | list
      }}

- name: Derive systemd/non-systemd start command groups
  ansible.builtin.set_fact:
    _systemd_start_names: >-
      {{
        _start_cmds
        | select('search','(?i)\\bsystemctl\\s+start\\s+')
        | map('regex_replace', '.*(?i)systemctl\\s+start\\s+(\\S+).*', '\\1')
        | list | unique
      }}
    _non_systemd_start_cmds: >-
      {{ _start_cmds | reject('search','(?i)\\bsystemctl\\s+start\\s+') | list }}

- block:
    - name: (check) BEFORE start hooks
      ansible.builtin.debug: { var: _start_before }
      when: _start_before | length > 0
    - name: (check) would start (Linux)
      ansible.builtin.debug: { var: _start_cmds }
    - name: (check) AFTER start hooks
      ansible.builtin.debug: { var: _start_after }
      when: _start_after | length > 0
    - name: Push simulated start summary (Linux)
      ansible.builtin.set_fact:
        start_health_summary: "{{ (start_health_summary | default([])) + [ {'component': 'all', 'start_fail': false, 'health_fail': false} ] }}"
      when: ansible_check_mode | default(false)

- block:
    - name: Start services (Linux) — using plan-defined commands
      ansible.builtin.shell: "{{ item }}"
      args: { executable: /bin/bash }
      loop: "{{ _start_cmds }}"
      register: _start_out
      become: false
      failed_when: false
      changed_when: true

    - name: DEBUG start results (rc/stdout/stderr)
      ansible.builtin.debug:
        msg: |
          command: {{ item.item }}
          rc: {{ item.rc | default('n/a') }}
          stdout:
          {{ (item.stdout | default('')) | indent(2) }}
          stderr:
          {{ (item.stderr | default('')) | indent(2) }}
      loop: "{{ _start_out.results | default([]) }}"
      when: _start_out is defined

    - name: BEFORE start hooks
      ansible.builtin.shell: "{{ item }}"
      args: { executable: /bin/bash }
      loop: "{{ _start_before }}"
      failed_when: false
      changed_when: true
      when: _start_before | length > 0

    - name: Collect failed start results (for debug; do not fail yet)
      ansible.builtin.set_fact:
        _failed_start_results: "{{ _start_out.results | default([]) | selectattr('rc','defined') | selectattr('rc','ne',0) | list }}"
      when: (_start_out.results | default([]) | selectattr('rc','defined') | selectattr('rc','ne',0) | list | length) > 0

    - name: Debug failed starts (rc/stdout/stderr)
      ansible.builtin.debug:
        msg: >-
          start_failures: {{ _failed_start_results | default([]) | map(attribute='item') | list | to_nice_json }}
      when: _failed_start_results is defined and _failed_start_results | length > 0

    - name: Fail if any start commands failed
      ansible.builtin.fail:
        msg: |
          START FAILED on {{ inventory_hostname }}
          Failing command(s):
          {% for r in (_failed_start_results | default([])) %}
          - {{ r.item }} (rc={{ r.rc | default('n/a') }})
            stdout:
          {{ (r.stdout | default('')) | indent(12) }}
            stderr:
          {{ (r.stderr | default('')) | indent(12) }}
          {% endfor %}
      when: _failed_start_results is defined and _failed_start_results | length > 0

    - name: AFTER start hooks
      ansible.builtin.shell: "{{ item }}"
      args: { executable: /bin/bash }
      loop: "{{ _start_after }}"
      failed_when: false
      changed_when: true
      when: _start_after | length > 0

    - name: Push start summary (Linux)
      ansible.builtin.set_fact:
        start_health_summary: "{{ (start_health_summary | default([])) + [ {'component': 'all', 'start_fail': false, 'health_fail': false } ] }}"
      when: not (ansible_check_mode | default(false))
===============================================================================================================================

#roles/deploy_service/tasks/start_only_windows.yml
- name: Build start & hooks (Windows)
  ansible.builtin.set_fact:
    _start_cmds: >-
      {{
        phase_services | map(attribute='containers') | sum(start=[])
        | map(attribute='serviceCommands') | select('defined')
        | map(attribute='start') | reject('equalto', None)
        | map('trim') | reject('equalto','') | list
      }}
    _start_before: >-
      {{
        phase_services | map(attribute='actionCommands') | sum(start=[])
        | selectattr('action','equalto','START')
        | selectattr('runStage','equalto','BEFORE')
        | map(attribute='command') | list
      }}
    _start_after: >-
      {{
        phase_services | map(attribute='actionCommands') | sum(start=[])
        | selectattr('action','equalto','START')
        | selectattr('runStage','equalto','AFTER')
        | map(attribute='command') | list
      }}

- block:
    - name: (check) BEFORE start hooks (Windows)
      ansible.builtin.debug: { var: _start_before }
      when: _start_before | length > 0
    - name: (check) would start (Windows)
      ansible.builtin.debug: { var: _start_cmds }
    - name: (check) AFTER start hooks (Windows)
      ansible.builtin.debug: { var: _start_after }
      when: _start_after | length > 0
    - name: Push simulated start summary (Windows)
      ansible.builtin.set_stats:
        data:
          start_health_summary: >-
            {{ (hostvars[inventory_hostname].start_health_summary | default([])) + [ {
              'service': 'batch',
              'start_ok':   [],
              'start_fail': []
            } ] }}
  when: ansible_check_mode | default(false)

- block:
    - name: BEFORE start hooks (Windows)
      ansible.windows.win_powershell:
        script: |
          try { {{ item }}; exit 0 } catch { exit 2 }
      loop: "{{ _start_before }}"
      failed_when: false
      when: _start_before | length > 0

    - name: Start services (Windows)
      ansible.windows.win_powershell:
        script: |
          try { {{ item }}; exit 0 } catch { exit 2 }
      loop: "{{ _start_cmds }}"
      register: _win_start
      failed_when: false

    - name: AFTER start hooks (Windows)
      ansible.windows.win_powershell:
        script: |
          try { {{ item }}; exit 0 } catch { exit 2 }
      loop: "{{ _start_after }}"
      failed_when: false
      when: _start_after | length > 0

    - name: Fail if any start commands failed (Windows)
      ansible.builtin.fail:
        msg: |
          START FAILED on {{ inventory_hostname }}
          Failing command(s): {{ (_win_start.results | default([]) | selectattr('rc','defined') | rejectattr('rc','eq',0) | map(attribute='item') | list) | join(' | ') }}
      when: (_win_start.results | default([]) | selectattr('rc','defined') | rejectattr('rc','eq',0) | list | length) > 0

    - name: Push start summary (Windows)
      ansible.builtin.set_stats:
        data:
          start_health_summary: >-
            {{ (hostvars[inventory_hostname].start_health_summary | default([])) + [ {
              'service': 'batch',
              'start_ok':   (_win_start.results | default([]) | selectattr('rc','defined') | selectattr('rc','eq',0) | map(attribute='item') | list),
              'start_fail': (_win_start.results | default([]) | selectattr('rc','defined') | rejectattr('rc','eq',0)   | map(attribute='item') | list)
            } ] }}
  when: not (ansible_check_mode | default(false))

