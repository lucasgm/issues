Here’s what’s going on and how to verify we’re executing the stop as you expect.

What’s Causing The Password Prompt

Inline sudo in serviceCommands: Your execplan uses “sudo /usr/bin/systemctl …”. When Ansible runs shell/command tasks non-interactively, sudo may require a TTY and/or a password, so it errors or prompts.
Different context than manual: You “became the service account” interactively and ran sudo successfully. Ansible runs as its own remote user without a TTY, so sudo behaves differently.
What The Playbook Does Now

STOP uses the plan-defined stop exactly, but strips a leading “sudo” and runs it with Ansible privilege escalation (become). That avoids TTY/password issues while honoring your specific command path and arguments.
START prefers systemd (restart) with become for systemctl-based starts, so “Active: since” updates correctly. Non-systemd start commands still run via shell.
Verification Debug

I added a STOP debug that prints the original and executed stop commands so you can confirm the exact string:
roles/deploy_service/tasks/stop_only_linux.yml: after computing _stop_clean
Turn it on with -e options.DEBUG=true
You’ll see output like:
original_stop_cmds: ["sudo /usr/bin/systemctl stop rop_edgeservice"]
executed_stop_cmds: ["/usr/bin/systemctl stop rop_edgeservice"]
Why executed != original

We intentionally drop the leading “sudo” and use become: true so Ansible elevates privileges without an interactive prompt. Functionally, this is equivalent to your original command but non-interactive and reliable under Ansible.
File References

execplan.yml: service commands defined for rop_edgeservice
execplan.yml:1 (component)
execplan.yml:9 (stop)
STOP role (normalized + debug + become)
roles/deploy_service/tasks/stop_only_linux.yml:1
roles/deploy_service/tasks/stop_only_linux.yml:12
roles/deploy_service/tasks/stop_only_linux.yml:18
START role (systemd restart with become)
roles/deploy_service/tasks/start_only_linux.yml:1
roles/deploy_service/tasks/start_only_linux.yml:38
How To Run And Inspect

Enable debug for STOP:
ansible-playbook playbook.yml -e options.DEBUG=true
Confirm in the STOP phase:
“original_stop_cmds” equals “sudo /usr/bin/systemctl stop rop_edgeservice”
“executed_stop_cmds” equals “/usr/bin/systemctl stop rop_edgeservice” (run with become)
If You Require Executing The Literal sudo Line

You can run the exact string including sudo, but then you must:
Ensure the Ansible remote user has passwordless sudo for that command and is not subject to requiretty, or
Use sudo’s non-interactive mode (sudo -n …) and set NOPASSWD rules. Without that, it will prompt/fail in Ansible.
The current approach (strip sudo + become) is the safer Ansible pattern and achieves the same effect.
