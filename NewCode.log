Chillo Deployments Using Ansible
Overview

Several teams within the organization have implemented artifact deployment automation using a variety of independent solutions, such as custom scripts, Java applications, and other ad hoc tools.
To streamline and modernize these efforts, we are aligning with the company-wide initiative to adopt Red Hat Ansible as the standard automation platform.
Ansible offers a unified, scalable framework that supports a wide range of automation needs—including artifact orchestration and deployments across distributed environments.

Impact on Chillo

No changes will be made to existing Chillo repositories, application code, or business logic.
The only modification involves replacing the current deployment mechanism with Red Hat Ansible, which will act as the underlying orchestration engine.
This integration leverages Chillo’s existing output files — execution-plan.json and servers.yml — generated during a dry run. These files provide comprehensive 
details about the deployment scope, including the artifacts and services to be updated, as well as the specific servers impacted by each action.

Automation Approach

Deployment automation will be initiated through GitHub Actions, offering an interface similar to what end users currently experience in Jenkins.

Implementation Plan
1. GitHub Workflow Inputs

We will create a manual GitHub workflow trigger (workflow_dispatch) that allows users to provide parameters such as:

TAG

Branch

Environment

Actions

Component Filter

Server Tag Filter

Additional parameters may be added in future iterations as needed.

2. Execution Plan Generation

The workflow will launch a Docker image containing the Chillo CLI, which will:

Generate the execution-plan.json, identical to the plan produced by Jenkins today.

Create the servers.yml, listing all servers for the selected environment along with their associated tags.

3. YAML Conversion for Ansible

A lightweight executable will process the generated files (execution-plan.json and servers.yml) and convert them into a concise execution-plan.yml format suitable for Ansible orchestration.

While the JSON version can span thousands of lines, the YAML version is optimized for readability and execution while retaining all necessary deployment details.

Example (excerpt):

- name: sdp-canola-config
  type: SERVICE
  dependsOn:
    - componentName: iceamazoncorretto.17.0.3.6.1
      reverseDependency: false
      currentAction: INSTALL
      dependsOnAction: INSTALL
      orchestrationOnly: true
  containers:
    - type: RPM
      groupId: com.theice.clearing.deliveries
      artifactId: ICEdel-config-server-rpm
      version: 1.10.3.2.0-SNAPSHOT
      rpmName: ICEdel-config-server-rpm
      serviceCommands:
        start: /usr/bin/sudo /var/opt/delcs/scripts/startStop.sh start icus
        stop: /usr/bin/sudo /var/opt/delcs/scripts/startStop.sh stop
        health: ps -ef | grep -i delcs | grep 'bin/java' | grep -vE 'spool|grep|bash|color=auto|mail' &>/dev/null && \
          curl -v --connect-timeout 10 --max-time {{timeout}} --retry {{retry}} \
          --retry-delay {{retryDelay}} --retry-connrefused http://localhost:15020/actuator/health | grep UP
        stopHealth: '! ps -ef | grep -i delcs | grep ''bin/java'' | grep -vE ''spool|grep|bash|color=auto|mail'' &>/dev/null'
  serverFilters:
    - m4s-i1-cudlas-01
    - m4s-i1-cudlas-02
  actionServerFilters:
    INSTALL: [m4s-i1-cudlas-01]
    START: [m4s-i1-cudlas-01]
    STOP: [m4s-i1-cudlas-01]
    HEALTH_CHECK: [m4s-i1-cudlas-01]
  lifecycle:
    - DOWNLOAD
    - START
    - HEALTH_CHECK

4. Deployment via Red Hat Ansible API

The generated execution-plan.yml will be passed to Ansible as an environment variable named EXECPLAN.
Ansible will then orchestrate the full deployment workflow across the specified environment and target servers.

5. Status Monitoring and Reporting

Once Ansible completes execution:

The system will check the job’s status (Success/Failure).

On success, the workflow ends cleanly.

On failure, detailed error information will be displayed, including:

The failing step(s)

Root cause summary

A URL link to detailed Ansible logs for further analysis

Key Benefits

Standardization: Aligns Chillo deployments with the organization’s Ansible-based automation strategy.

Scalability: Enables orchestrated deployments across multiple environments and servers.

Visibility: Provides structured reporting and centralized logging for easier troubleshooting.

Reusability: Leverages GitHub Actions and Docker for consistent and repeatable automation.
