Chillo Deployments Using Ansible
Overview

The current deployment process for Chillo relies on a mix of automation tools—custom scripts, Java applications, and other ad-hoc solutions—developed independently by various teams.
To standardize and modernize deployment automation across the organization, we are aligning with the company-wide initiative to adopt Red Hat Ansible.
Ansible provides a unified platform capable of handling multiple automation needs, including artifact orchestration and deployment across distributed environments.

Impact on Chillo

We are not modifying any existing Chillo repositories, application code, or business logic.
The only change is replacing the current deployment mechanism with Ansible, which will serve as the underlying orchestration tool.

Automation Approach

Deployment automation will be initiated through GitHub Actions, offering an interface similar to what end users currently experience in Jenkins.

Implementation Plan
1. GitHub Workflow Inputs

We will create a manual GitHub workflow trigger (workflow_dispatch) that allows users to provide parameters such as:

TAG

Branch

Environment

Actions

Component Filter

Server Tag Filter

Additional parameters may be added in future iterations as needed.

2. Execution Plan Generation

The workflow will launch a Docker image containing the Chillo CLI, which will:

Generate the execution-plan.json, identical to the plan produced by Jenkins today.

Create the servers.yml, listing all servers for the selected environment along with their associated tags.

3. YAML Conversion for Ansible

A lightweight executable will process the generated files (execution-plan.json and servers.yml) and convert them into a concise execution-plan.yml format suitable for Ansible orchestration.

While the JSON version can span thousands of lines, the YAML version is optimized for readability and execution while retaining all necessary deployment details.

Example (excerpt):

- name: sdp-canola-config
  type: SERVICE
  dependsOn:
    - componentName: iceamazoncorretto.17.0.3.6.1
      reverseDependency: false
      currentAction: INSTALL
      dependsOnAction: INSTALL
      orchestrationOnly: true
  containers:
    - type: RPM
      groupId: com.theice.clearing.deliveries
      artifactId: ICEdel-config-server-rpm
      version: 1.10.3.2.0-SNAPSHOT
      rpmName: ICEdel-config-server-rpm
      serviceCommands:
        start: /usr/bin/sudo /var/opt/delcs/scripts/startStop.sh start icus
        stop: /usr/bin/sudo /var/opt/delcs/scripts/startStop.sh stop
        health: ps -ef | grep -i delcs | grep 'bin/java' | grep -vE 'spool|grep|bash|color=auto|mail' &>/dev/null && \
          curl -v --connect-timeout 10 --max-time {{timeout}} --retry {{retry}} \
          --retry-delay {{retryDelay}} --retry-connrefused http://localhost:15020/actuator/health | grep UP
        stopHealth: '! ps -ef | grep -i delcs | grep ''bin/java'' | grep -vE ''spool|grep|bash|color=auto|mail'' &>/dev/null'
  serverFilters:
    - m4s-i1-cudlas-01
    - m4s-i1-cudlas-02
  actionServerFilters:
    INSTALL: [m4s-i1-cudlas-01]
    START: [m4s-i1-cudlas-01]
    STOP: [m4s-i1-cudlas-01]
    HEALTH_CHECK: [m4s-i1-cudlas-01]
  lifecycle:
    - DOWNLOAD
    - START
    - HEALTH_CHECK

4. Deployment via Red Hat Ansible API

The generated execution-plan.yml will be passed to Ansible as an environment variable named EXECPLAN.
Ansible will then orchestrate the full deployment workflow across the specified environment and target servers.

5. Status Monitoring and Reporting

Once Ansible completes execution:

The system will check the job’s status (Success/Failure).

On success, the workflow ends cleanly.

On failure, detailed error information will be displayed, including:

The failing step(s)

Root cause summary

A URL link to detailed Ansible logs for further analysis

Key Benefits

Standardization: Aligns Chillo deployments with the organization’s Ansible-based automation strategy.

Scalability: Enables orchestrated deployments across multiple environments and servers.

Visibility: Provides structured reporting and centralized logging for easier troubleshooting.

Reusability: Leverages GitHub Actions and Docker for consistent and repeatable automation.
